import 'package:antlr4/src/tree/src/tree.dart';
import 'package:dart_native_codegen/parser/objc/ObjectiveCParser.dart';

class DNContext {
  var internal;
  DNContext parent;
  List<DNContext> children;
  DNContext(internal) {
    this.internal = internal;
    this.parent = null;
    this.children = [];
  }

  void addChild(ctx) {
    ctx.parent = this;
    this.children.add(ctx);
  }

  String parse() {
    return '';
  }
}

class DNRootContext extends DNContext {
  var needExport;
  DNRootContext(internal, needExport) : super(internal) {
    this.needExport = needExport;
  }

  parse() {
    var result = '';
    result +=
        '// Generated by dart_native_codegen\n// https://pub.dev/packages/dart_native_codegen\n\n';
    var packageSet = new Set();
    if (!this.needExport) {
      result += "import 'dart:ffi';\n\n";
      result += "import 'package:dart_native/dart_native.dart';\n";
      result += "import 'package:dart_native_gen/dart_native_gen.dart';\n";
      packageSet.add('dart_native');
      packageSet.add('dart_native_gen');
    }
    // result += this.children.map(ctx => {
    //     var childResult = ctx.parse()
    //     // if (!(ctx is DNImportContext)) {
    //     //     childResult = '\n' + childResult
    //     // } else {
    //     packageSet.add(ctx.package)
    //     // }
    //     return childResult
    // }).join('\n');
    result += this.children.map((ctx) => ctx.parse()).join('\n');
    return (result);
  }
}

class DNOSVersionContext extends DNContext {
  String os;
  String min;
  String max;
  DNOSVersionContext(internal) : super(internal) {
    if (internal is OsVersionContext) {
      OsVersionContext versionContextInternal = internal;
      this.os = versionContextInternal.os.text;
      this.min = versionContextInternal.min.text;
      if (versionContextInternal.max != null) {
        this.max = versionContextInternal.max.text;
      }
    }
  }

  parse() {
    var result = this.os;
    if (this.max.isNotEmpty) {
      result += ': ' + '[\'' + this.min + '\', \'' + this.max + '\']';
    } else {
      result += ': ' + '\'' + this.min + '\'';
    }
    return result;
  }
}

class DNAvailabilityContext extends DNContext {
  String name;
  List<DNOSVersionContext> osVersions = [];
  List<String> message;
  DNAvailabilityContext(internal) : super(internal) {
    if (internal is MacroContext) {
      MacroContext macroContext = internal;
      this.name = macroContext.start.text;
      Iterable<ParseTree> children =
          macroContext.messages.map((cxt) => cxt.children[0]);

      macroContext.osVersions().forEach((cxt) {
        this.osVersions.add(DNOSVersionContext(cxt));
      });
    }
  }
}

class DNBlockDefContext extends DNContext {
  String returnType = '';
  String defName = null;
  List args = [];
  DNBlockDefContext(internal) : super(internal);

  parse() {
    String argList = '';
    this.args.asMap().keys.map((index) => {
          if (index == this.args.length - 1)
            {argList += args[index].type + ' ' + args[index].name}
          else
            {argList += args[index].type + ' ' + args[index].name + ', '}
        });
    var result = 'typedef ';
    result += this.returnType + ' ' + this.defName + '(' + argList + ');';
    return result;
  }
}

class DNEnumItemContext extends DNContext {
  String name = '';
  String type = null;
  String value = null;
  List macros = [];
  List availability = [];

  DNEnumItemContext(internal) : super(internal) {
    this.name = internal.name.start.text;
  }

  parse() {
    var result = this.availability.map((a) => a.parse()).join(' ') + '\n';
    this.value = this.value.toString().replaceAll('UL', '');
    if (this.type.isNotEmpty) {
      result += 'const ' +
          this.type +
          ' ' +
          this.name +
          ' = ' +
          this.type +
          '(' +
          this.value +
          ');\n';
    } else {
      result += 'const int ' + this.name + ' = ' + this.value + ';\n';
    }
    return result;
  }
}

class DNEnumDefContext extends DNContext {
  String defName = '';
  String type = null;
  String value = null;
  Map enumMap = {};
  List macros = [];
  List availability = [];

  DNEnumDefContext(internal) : super(internal) {
    if (internal.name) {
      this.defName = internal.name.start.text;
    }
  }

  parse() {
    var result = '\n';
    if (this.defName.isNotEmpty) {
      var availability =
          this.availability.map((a) => a.parse()).join(' ') + '\n';
      var superClass = 'NSEnum';
      if (this.type == 'NS_OPTIONS') {
        superClass = 'NSOptions';
      }
      result += availability +
          'class ' +
          this.defName +
          ' extends ' +
          superClass +
          ' {\n' +
          '  const ' +
          this.defName +
          '(dynamic raw) : super(raw);\n' +
          '  ' +
          this.defName +
          '.fromPointer(Pointer<Void> ptr) : super(ptr.address);\n' +
          '}\n\n';
    }

    for (var key in this.enumMap.keys) {
      result += this.enumMap[key].parse();
    }
    return result;
  }
}

class DNArgumentContext extends DNContext {
  String name = null;
  String type = '';
  bool isBlock = false;
  bool isNullable = false;
  bool isOutParam = false;
  DNArgumentContext(internal) : super(internal) {
    if (internal.name && internal.types) {
      this.name = internal.name.start.text;
    }
  }
}
