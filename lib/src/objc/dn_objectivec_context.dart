import 'package:antlr4/antlr4.dart';
import 'package:dart_native_codegen/common/utils.dart';

import '../../parser/objc/ObjectiveCParser.dart';
import 'dn_objectivec_type_converter.dart';

class DNContext extends BaseContext {
  DNContext parent;
  List<DNContext> children;
  DNContext(internal) {
    this.internal = internal;
    this.parent = null;
    this.children = [];
  }

  void addChild(ctx) {
    ctx.parent = this;
    this.children.add(ctx);
  }

  String parse() {
    return '';
  }
}

abstract class BaseContext {
  String name = null;
  var internal = null;
  List methods = null;
  String type = null;
  bool isNullable = false;
}

class DNRootContext extends DNContext {
  var needExport;
  DNRootContext(internal, needExport) : super(internal) {
    this.needExport = needExport;
  }

  parse() {
    var result = '';
    result +=
        '// Generated by dart_native_codegen.\n// https://pub.dev/packages/dart_native_codegen\n\n';
    var packageSet = new Set();
    if (!this.needExport) {
      result += "import 'dart:ffi';\n\n";
      result += "import 'package:dart_native/dart_native.dart';\n";
      result += "import 'package:dart_native_gen/dart_native_gen.dart';\n";
      packageSet.add('dart_native');
      packageSet.add('dart_native_gen');
    }
    // result += this.children.map(ctx => {
    //     var childResult = ctx.parse()
    //     // if (!(ctx is DNImportContext)) {
    //     //     childResult = '\n' + childResult
    //     // } else {
    //     packageSet.add(ctx.package)
    //     // }
    //     return childResult
    // }).join('\n');
    result += this.children.map((ctx) => ctx.parse()).join('\n');
    return (result);
  }
}

class DNOSVersionContext extends DNContext {
  String os;
  String min;
  String max;
  DNOSVersionContext(internal) : super(internal) {
    if (internal is OsVersionContext) {
      OsVersionContext versionContextInternal = internal;
      this.os = versionContextInternal.os.text;
      this.min = versionContextInternal.min.text;
      if (versionContextInternal.max != null) {
        this.max = versionContextInternal.max.text;
      }
    }
  }

  parse() {
    var result = this.os;
    if (this.max.isNotEmpty) {
      result += ': ' + '[\'' + this.min + '\', \'' + this.max + '\']';
    } else {
      result += ': ' + '\'' + this.min + '\'';
    }
    return result;
  }
}

class DNAvailabilityContext extends DNContext {
  String name;
  List<DNOSVersionContext> osVersions = [];
  List<String> message;
  DNAvailabilityContext(internal) : super(internal) {
    if (internal is MacroContext) {
      MacroContext macroContext = internal;
      this.name = macroContext.start.text;
      // ignore: unused_local_variable
      Iterable<ParseTree> children =
          macroContext.messages.map((cxt) => cxt.children[0]);

      macroContext.osVersions().forEach((cxt) {
        this.osVersions.add(DNOSVersionContext(cxt));
      });
    }
  }
}

class DNBlockDefContext extends DNContext {
  String returnType = '';
  String defName = null;
  List args = [];
  DNBlockDefContext(internal) : super(internal);

  parse() {
    String argList = '';
    this.args.asMap().keys.map((index) => {
          if (index == this.args.length - 1)
            {argList += args[index].type + ' ' + args[index].name}
          else
            {argList += args[index].type + ' ' + args[index].name + ', '}
        });
    var result = 'typedef ';
    result += this.returnType + ' ' + this.defName + '(' + argList + ');';
    return result;
  }
}

class DNEnumItemContext extends DNContext {
  String name = '';
  String type = null;
  String value = null;
  List macros = [];
  List availability = [];

  DNEnumItemContext(internal) : super(internal) {
    this.name = internal.name.start.text;
  }

  parse() {
    var result = this.availability.map((a) => a.parse()).join(' ') + '\n';
    this.value = this.value.toString().replaceAll('UL', '');
    if (this.type.isNotEmpty) {
      result += 'const ' +
          this.type +
          ' ' +
          this.name +
          ' = ' +
          this.type +
          '(' +
          this.value +
          ');\n';
    } else {
      result += 'const int ' + this.name + ' = ' + this.value + ';\n';
    }
    return result;
  }
}

class DNEnumDefContext extends DNContext {
  String defName = '';
  String type = null;
  String value = null;
  Map enumMap = {};
  List macros = [];
  List availability = [];

  DNEnumDefContext(internal) : super(internal) {
    if (internal.name) {
      this.defName = internal.name.start.text;
    }
  }

  parse() {
    var result = '\n';
    if (this.defName.isNotEmpty) {
      var availability =
          this.availability.map((a) => a.parse()).join(' ') + '\n';
      var superClass = 'NSEnum';
      if (this.type == 'NS_OPTIONS') {
        superClass = 'NSOptions';
      }
      result += availability +
          'class ' +
          this.defName +
          ' extends ' +
          superClass +
          ' {\n' +
          '  const ' +
          this.defName +
          '(dynamic raw) : super(raw);\n' +
          '  ' +
          this.defName +
          '.fromPointer(Pointer<Void> ptr) : super(ptr.address);\n' +
          '}\n\n';
    }

    for (var key in this.enumMap.keys) {
      result += this.enumMap[key].parse();
    }
    return result;
  }
}

class DNArgumentContext extends DNContext {
  String name = null;
  String type = '';
  bool isBlock = false;
  bool isNullable = false;
  bool isOutParam = false;
  DNArgumentContext(internal) : super(internal) {
    if (internal.name && internal.types) {
      this.name = internal.name.start.text;
    }
  }
}

class DNMethodContext extends DNContext {
  String methodName = null;
  List<String> names = [];
  List<DNArgumentContext> args = [];
  String returnType = null;
  bool callFromPointer = false;
  bool isClassMethod = false;
  List macros = [];
  List availability = [];
  bool isSingleInstanceConstr = false;
  List nullableArgs = null;

  DNMethodContext(internal) : super(internal);

  parse() {
    if (this.args.length == 0 && this.hasSameMethodDeclaration()) {
      return '';
    } else if (this.args.length == 1 && this.hasSameMethodDeclaration()) {
      return this.parseForOptionalSingleArg();
    }
    //fix:Extensions can't declare constructors

    var isExtensionMethod = this.parent is DNCategoryContext;
    var isInstanceConstr = (this.returnType == this.parent.name) &&
        !this.isClassMethod &&
        !isExtensionMethod;
    if (isInstanceConstr) {
      return this.constructorImpl();
    } else {
      var result =
          '  ' + this.availability.map((a) => a.parse()).join(' ') + '\n';
      result += '  ' +
          (this.isClassMethod ? 'static ' : '') +
          this.convertMutableTypeIfNeed(this.returnType) +
          ' ' +
          this.methodDeclaration() +
          this.methodArgs() +
          ' {\n';
      result += this.preHandleMutableArgsIfNeed() + '    ' + this.methodImpl();
      result += '  }';
      return result;
    }
  }

  preHandleMutableArgsIfNeed() {
    var result = '';
    this.args.forEach((value) {
      var rawType = rawGenericType(value.type);
      if (DNObjectiveCTypeConverter.supportMutableTypes.indexOf(rawType) > -1) {
        var tmpArgName = '_' + value.name;
        result += '    ' +
            rawType +
            ' ' +
            tmpArgName +
            ' = ' +
            rawType +
            '(' +
            value.name +
            ');\n';
        value.name = tmpArgName;
      }
    });
    return result;
  }

  hasSameMethodDeclaration() {
    var methods = this.parent.methods;
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      if (this != method &&
          this.methodDeclaration() == method.methodDeclaration() &&
          this.isClassMethod == method.isClassMethod) {
        return true;
      }
    }
    return false;
  }

  methodDeclaration() {
    String methodDeclaration = '';
    this.args.asMap().keys.forEach((index) {
      methodDeclaration += index >= 1
          ? this
              .names[index]
              .replaceFirstMapped('/^\w/', (match) => match.input.toUpperCase())
          : this.names[index];
    });
    methodDeclaration =
        methodDeclaration.isNotEmpty ? methodDeclaration : this.methodName;
    return methodDeclaration;
  }

  methodImpl({bool noArg = false}) {
    if (!noArg) {
      noArg = this.args.length == 0;
    }
    var callerPrefix =
        (this.isClassMethod ? ' Class(\'' + this.parent.name + '\').' : ' ');
    String argsStr = this.args.asMap().values.map((e) => e.name).toString();
    var args = noArg ? '' : ', args: [' + argsStr + ']';
    var impl = callerPrefix +
        'perform(SEL(\'' +
        this.ocMethodName() +
        '\')' +
        args +
        ');\n';

    var rawRetType = rawGenericType(this.returnType); //remove <> symbol
    var isMutableRetType =
        DNObjectiveCTypeConverter.supportMutableTypes.indexOf(rawRetType) > -1;

    if (!isMutableRetType && !this.callFromPointer) {
      return (this.returnType == 'void' ? '' : 'return') + impl;
    }

    var newImpl = 'Pointer<Void> result =' +
        impl.replaceAll(');\n', '') +
        ', decodeRetVal: false);\n';
    if (this.callFromPointer) {
      String supportType = DNObjectiveCTypeConverter.dartToOCMap[rawRetType];
      if (supportType.isNotEmpty) {
        newImpl += '    return ' + supportType + '.fromPointer(result).raw;\n';
      } else if (isMutableRetType) {
        newImpl += '    return ' + rawRetType + '.fromPointer(result).raw;\n';
      } else {
        newImpl += '    return ' + rawRetType + '.fromPointer(result);\n';
      }
    }
    return newImpl;
  }

  constructorImpl() {
    var result = '';
    if (this.isSingleInstanceConstr) {
      // such as NSError(arg x)
      result += '  ' + this.parent.name + this.methodArgs() + '\n';
    } else {
      // such as NSError.initWithxxxx(arg x)
      result += '  ' +
          this.parent.name +
          '.' +
          this.methodDeclaration() +
          this.methodArgs() +
          '\n';
    }
    result += '     : super.fromPointer(_' +
        this.methodDeclaration() +
        '(' +
        this.args.asMap().values.map((e) => e.name).toString() +
        '));\n';
    result += '\n';
    result += '  static Pointer<Void> _' +
        this.methodDeclaration() +
        this.methodArgs() +
        ' {\n';
    result += this.preHandleMutableArgsIfNeed();
    result += '    Pointer<Void> target = alloc(Class(\'' +
        this.parent.name +
        '\'));\n';
    result += '    SEL sel = SEL(\'' + this.ocMethodName() + '\');\n';
    result += '    return msgSend(target, sel, ' +
        'args: [' +
        this.args.asMap().values.map((e) => e.name).toString() +
        ']' +
        ', decodeRetVal: false);\n';
    result += '  }\n';
    return result;
  }

  methodArgs({bool optional = false}) {
    //convert as follows: int a, String b, {int c, String d}
    var argList = optional ? '([' : '(';
    this.nullableArgs = List();
    this.args.asMap().keys.forEach((index) {
      var element = this.args[index];
      if (element != null) {
        nullableArgs.add(element);
      } else {
        var argType = element.isOutParam
            ? 'NSObjectRef<' + element.type + '>'
            : element.type;
        var arg = element.isBlock
            ? argType
            : this.convertMutableTypeIfNeed(argType) + ' ' + element.name;
        argList += arg +
            (index == this.args.length - 1 && nullableArgs.length == 0
                ? ''
                : ', ');
      }
    });

    if (nullableArgs.length > 0) {
      argList += '{';
      nullableArgs.asMap().keys.forEach((index) {
        var element = this.args[index];
        var argType = element.isOutParam
            ? 'NSObjectRef<' + element.type + '>'
            : element.type;
        var arg = element.isBlock
            ? argType
            : this.convertMutableTypeIfNeed(argType) + ' ' + element.name;
        argList += arg + (index == nullableArgs.length - 1 ? '' : ', ');
      });
      argList += '}';
    }
    argList += optional ? '])' : ')';
    return argList;
  }

  parseForOptionalSingleArg() {
    var optionalArgType = this.args[0].type;
    var optionalArgName = this.args[0].name;
    var result = '  ' +
        (this.isClassMethod ? 'static ' : '') +
        this.returnType +
        ' ' +
        this.methodDeclaration() +
        '([' +
        optionalArgType +
        ' ' +
        optionalArgName +
        '])' +
        ' {\n';
    result += '    if (' + optionalArgName + ' != null) {\n';
    result += '         ' + this.methodImpl();
    result += '    } else { \n';
    result += '         ' + this.methodImpl(noArg: true);
    result += '    }\n';
    result += '  }';
    return result;
  }

  convertMutableTypeIfNeed(type) {
    var rawType = rawGenericType(type);
    bool dartType =
        DNObjectiveCTypeConverter.supportMutableTypesMap[rawType].isNotEmpty;
    var ret = dartType ? type.replace(rawType, dartType) : type;
    return ret;
  }

  ocMethodName() {
    var funcName = '';
    this.nullableArgs.asMap().keys.forEach((index) {
      funcName += this.names[index] + (this.args.length >= 1 ? ':' : '');
    });
    funcName = funcName.isNotEmpty ? funcName : this.methodName;
    return funcName;
  }
}

class DNCategoryContext extends DNContext {
  String host = null;
  String name = null;
  List properties = [];
  List protocols = null;

  DNCategoryContext(internal) : super(internal) {
    this.host = internal.runtimeType.start.text;
    if (internal is CategoryInterfaceContext) {
      if (internal.categoryName != null) {
        this.name = internal.categoryName.start.text;
      } else {
        this.name = 'DartNative';
      }
      this.protocols = internal.protocols.list;
      // this.protocols = protocols != null && protocols.length > 0 ? protocols.forEach((element) {
      //   return element.name.start.text;
      // });
    }
  }
  // constructor(internal) {
  //     super(internal)
  //     this.host = internal.className.start.text;
  //     if (internal.categoryName) {
  //         this.name = internal.categoryName.start.text;
  //     } else {
  //         this.name = 'DartNative';
  //     }
  //     this.protocols = internal.protocols;
  //     this.protocols = protocols ? protocols.forEach((p) => {
  //         return p.name.start.text;
  //     }) : [];
  // }

  parse() {
    var result = 'extension ' + this.host + this.name + ' on ' + this.host;
    result += ' {\n';

    this.properties.forEach((element) {
      result += element.parse() + '\n';
    });
    this.methods.forEach((element) {
      result += element.parse() + '\n';
    });
    result += '\n}';
    return result;
  }
}
